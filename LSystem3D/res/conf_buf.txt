
https://www.csh.rit.edu/~aidan/portfolio/3DLSystems.shtml

//Create the vertices for the mesh 
 std::vector<std::vector<glm::vec3>> meshGeometry; 
 for (int i = 0; i < pointCollections.size(); i++) 
 { 
  std::vector<glm::vec3> pointsForIteration; 
  for (int n = 0; n < pointsPerLevel; n++) 
  { 
   glm::vec3 vertex; 
   vertex = pointCollections[i].first; 
   glm::vec3 radVec = pointCollections[i].second; 
   glm::vec3 rotAxis = vertex; 
   if (i - 1 > 0) 
    rotAxis = rotAxis - pointCollections[i - 1].first; 
   if (glm::length(vertex) > 0) 
    rotAxis = glm::normalize(rotAxis); 
   else if (i + 1 < pointCollections.size()) 
    rotAxis = pointCollections[i + 1].first - rotAxis; 
   else //Assume 0,1,0 
    rotAxis = glm::vec3(0, 1, 0); 
   float theta = 2 * PI / pointsPerLevel * n; 
   radVec = radVec * cos(theta) + (glm::cross(rotAxis, radVec)) * sin(theta) + rotAxis * (glm::dot(rotAxis, radVec))* (1 - cos(theta)); 
   pointsForIteration.push_back(vertex + radVec); 
  } 
  meshGeometry.push_back(pointsForIteration); 
 }